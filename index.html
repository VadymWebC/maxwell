<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<title>EM Field Viz (Three.js)</title>
		<style>
			body {
				margin: 0;
				background: #121212;
			}
		</style>
	</head>
	<body>
		<script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>
		<script>
			/*const scene = new THREE.Scene()
			const camera = new THREE.PerspectiveCamera(
				75,
				window.innerWidth / window.innerHeight,
				0.1,
				1000
			)
			const renderer = new THREE.WebGLRenderer({ antialias: true })
			renderer.setSize(window.innerWidth, window.innerHeight)
			document.body.appendChild(renderer.domElement)
			camera.position.set(6, 6, 12)
			camera.lookAt(0, 0, 0)

			// –ü–∞—Ä–∞–º–µ—Ç—Ä—ã –≤–æ–ª–Ω—ã
			const N = 100
			const dz = 0.3
			const E0 = 2.5
			const B0 = 1.5
			const k = 1
			const omega = 2

			// –°—Ç—Ä–µ–ª–∫–∏
			let E_arrows = []
			let B_arrows = []

			for (let i = 0; i < N; i++) {
				const z = (i - N / 2) * dz
				const origin = new THREE.Vector3(0, 0, z)

				const E_arrow = new THREE.ArrowHelper(
					new THREE.Vector3(1, 0, 0),
					origin.clone(),
					0,
					0x00ffff
				)
				const B_arrow = new THREE.ArrowHelper(
					new THREE.Vector3(0, 1, 0),
					origin.clone(),
					0,
					0x00ff00
				)

				scene.add(E_arrow)
				scene.add(B_arrow)

				E_arrows.push(E_arrow)
				B_arrows.push(B_arrow)
			}

			let time = 0

			function animate() {
				requestAnimationFrame(animate)
				time += 0.05

				for (let i = 0; i < N; i++) {
					const z = (i - N / 2) * dz

					const E_mag = E0 * Math.sin(k * z - omega * time)
					const B_mag = B0 * Math.sin(k * z - omega * time)

					E_arrows[i].setLength(Math.abs(E_mag))
					E_arrows[i].setDirection(
						new THREE.Vector3(Math.sign(E_mag) || 1, 0, 0)
					)

					B_arrows[i].setLength(Math.abs(B_mag))
					B_arrows[i].setDirection(
						new THREE.Vector3(0, Math.sign(B_mag) || 1, 0)
					)
				}

				renderer.render(scene, camera)
			}

			animate()*/
		</script>
		<script>
			function makeTextSprite(message, parameters = {}) {
				const fontface = parameters.fontface || "Arial Black"
				const fontsize = parameters.fontsize || 96 // –ï—â—ë –∫—Ä—É–ø–Ω–µ–µ

				const canvas = document.createElement("canvas")
				canvas.width = 4096 // –ë–û–õ–¨–®–û–ô —Ö–æ–ª—Å—Ç
				canvas.height = 512

				const context = canvas.getContext("2d")
				context.clearRect(0, 0, canvas.width, canvas.height)

				context.font = `bold ${fontsize}px ${fontface}`
				context.fillStyle = "white" // —è—Ä–∫–∏–π –±–µ–ª—ã–π
				context.textBaseline = "top"
				context.fillText(message, 50, 50)

				const texture = new THREE.CanvasTexture(canvas)
				texture.needsUpdate = true
				texture.minFilter = THREE.LinearFilter

				const spriteMaterial = new THREE.SpriteMaterial({
					map: texture,
					transparent: true,
				})
				const sprite = new THREE.Sprite(spriteMaterial)

				// –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –º–∞—Å—à—Ç–∞–±–∞ –ø–æ –¥–ª–∏–Ω–µ —Å—Ç—Ä–æ–∫–∏
				const scaleX = message.length * 1.2
				sprite.scale.set(scaleX, 6, 1) // —à–∏—Ä–µ –∏ –≤—ã—à–µ

				return sprite
			}

			const scene = new THREE.Scene()
			const camera = new THREE.PerspectiveCamera(
				75,
				window.innerWidth / window.innerHeight,
				0.1,
				1000
			)
			const renderer = new THREE.WebGLRenderer({ antialias: true })
			renderer.setSize(window.innerWidth, window.innerHeight)
			document.body.appendChild(renderer.domElement)
			camera.position.set(10, 10, 20)
			camera.lookAt(0, 0, 0)

			const N = 100 // –∫–æ–ª-–≤–æ —Ç–æ—á–µ–∫ –≤–¥–æ–ª—å –æ—Å–∏ Z
			const dz = 0.5 // —à–∞–≥ –ø–æ –ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤—É
			const dt = 0.05 // —à–∞–≥ –ø–æ –≤—Ä–µ–º–µ–Ω–∏
			const c = 1 // —Å–∫–æ—Ä–æ—Å—Ç—å —Å–≤–µ—Ç–∞ (–≤ –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω—ã—Ö –µ–¥–∏–Ω–∏—Ü–∞—Ö)

			let E = new Array(N).fill(0)
			let B = new Array(N).fill(0)

			const E_arrows = []
			const B_arrows = []

			for (let i = 0; i < N; i++) {
				const z = (i - N / 2) * dz
				const origin = new THREE.Vector3(0, 0, z)

				const E_arrow = new THREE.ArrowHelper(
					new THREE.Vector3(1, 0, 0),
					origin.clone(),
					0,
					0x00ffff
				)
				const B_arrow = new THREE.ArrowHelper(
					new THREE.Vector3(0, 1, 0),
					origin.clone(),
					0,
					0x00ff00
				)

				scene.add(E_arrow)
				scene.add(B_arrow)
				E_arrows.push(E_arrow)
				B_arrows.push(B_arrow)
			}

			// üî• –Ω–∞—á–∞–ª—å–Ω–æ–µ –≤–æ–∑–º—É—â–µ–Ω–∏–µ ‚Äî –∏–º–ø—É–ª—å—Å –≤ —Ü–µ–Ω—Ç—Ä–µ
			E[Math.floor(N / 2)] = 1

			const formula1 = makeTextSprite("E·µ¢‚Åø‚Å∫¬π = E·µ¢‚Åø + (c¬∑dt/dz)¬∑(B·µ¢‚Åø - B·µ¢‚Çã‚ÇÅ‚Åø)")
			formula1.position.set(-8, 7, 0)
			scene.add(formula1)

			const formula2 = makeTextSprite("B·µ¢‚Åø‚Å∫¬π = B·µ¢‚Åø + (c¬∑dt/dz)¬∑(E·µ¢‚Çä‚ÇÅ‚Åø - E·µ¢‚Åø)")
			formula2.position.set(-8, 6, 0)
			scene.add(formula2)

			function animate() {
				requestAnimationFrame(animate)

				// üîÅ –†–∞—Å—á—ë—Ç E
				for (let i = 1; i < N - 1; i++) {
					E[i] += ((c * dt) / dz) * (B[i] - B[i - 1])
				}

				// üîÅ –†–∞—Å—á—ë—Ç B
				for (let i = 0; i < N - 1; i++) {
					B[i] += ((c * dt) / dz) * (E[i + 1] - E[i])
				}

				// üéØ –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –≤–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏–∏
				for (let i = 0; i < N; i++) {
					const eVal = E[i]
					const bVal = B[i]

					const scaleFactor = 5
					E_arrows[i].setLength(scaleFactor * Math.abs(eVal))
					E_arrows[i].setDirection(
						new THREE.Vector3(Math.sign(eVal) || 1, 0, 0)
					)

					B_arrows[i].setLength(scaleFactor * Math.abs(bVal))
					B_arrows[i].setDirection(
						new THREE.Vector3(0, Math.sign(bVal) || 1, 0)
					)
				}

				renderer.render(scene, camera)
			}

			animate()
		</script>
	</body>
</html>
